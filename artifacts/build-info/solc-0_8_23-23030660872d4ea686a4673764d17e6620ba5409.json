{
  "_format": "hh3-sol-build-info-1",
  "id": "solc-0_8_23-23030660872d4ea686a4673764d17e6620ba5409",
  "solcVersion": "0.8.23",
  "solcLongVersion": "0.8.23+commit.f704f362",
  "userSourceNameMap": {
    "contracts/RenOsOracle.sol": "project/contracts/RenOsOracle.sol"
  },
  "input": {
    "language": "Solidity",
    "settings": {
      "evmVersion": "shanghai",
      "outputSelection": {
        "*": {
          "": [
            "ast"
          ],
          "*": [
            "abi",
            "evm.bytecode",
            "evm.deployedBytecode",
            "evm.methodIdentifiers",
            "metadata"
          ]
        }
      },
      "remappings": []
    },
    "sources": {
      "project/contracts/RenOsOracle.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.23;\n\ninterface IERC20 {\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n    function transfer(address recipient, uint256 amount) external returns (bool);\n    function balanceOf(address account) external view returns (uint256);\n}\n\n/**\n * @title RenOsOracle\n * @dev Real-world cleaning business oracle - agents stake USDC on predictions\n * @notice Built by Friday (AI agent) for the USDC Hackathon on Moltbook\n */\ncontract RenOsOracle {\n    IERC20 public immutable usdc;\n    address public owner;\n    uint256 public marketCount;\n    \n    enum MarketStatus { Active, Resolved }\n    enum Outcome { Pending, Yes, No }\n    \n    struct Market {\n        string question;           // \"Will February revenue exceed 50,000 DKK?\"\n        uint256 targetValue;       // 50000 (in DKK cents)\n        uint256 deadline;          // Unix timestamp\n        uint256 yesPool;          // Total USDC staked on YES\n        uint256 noPool;           // Total USDC staked on NO\n        MarketStatus status;\n        Outcome outcome;\n        uint256 actualValue;       // Resolved value from Billy.dk\n        string dataSource;         // \"Billy Invoice #1234\"\n    }\n    \n    struct Stake {\n        uint256 amount;\n        bool isYes;               // true = YES, false = NO\n        bool claimed;\n    }\n    \n    mapping(uint256 => Market) public markets;\n    mapping(uint256 => mapping(address => Stake)) public stakes;\n    \n    event MarketCreated(uint256 indexed marketId, string question, uint256 targetValue, uint256 deadline);\n    event Staked(uint256 indexed marketId, address indexed staker, uint256 amount, bool isYes);\n    event MarketResolved(uint256 indexed marketId, Outcome outcome, uint256 actualValue, string dataSource);\n    event Claimed(uint256 indexed marketId, address indexed staker, uint256 payout);\n    \n    constructor(address _usdc) {\n        usdc = IERC20(_usdc);\n        owner = msg.sender;\n    }\n    \n    modifier onlyOwner() {\n        require(msg.sender == owner, \"Only owner\");\n        _;\n    }\n    \n    /**\n     * @dev Create a new prediction market\n     * @param question Human-readable question\n     * @param targetValue Threshold value (e.g., 50000 for 50k DKK)\n     * @param deadline Unix timestamp when betting closes\n     */\n    function createMarket(\n        string calldata question,\n        uint256 targetValue,\n        uint256 deadline\n    ) external onlyOwner returns (uint256) {\n        require(deadline > block.timestamp, \"Deadline must be future\");\n        \n        uint256 marketId = marketCount++;\n        markets[marketId] = Market({\n            question: question,\n            targetValue: targetValue,\n            deadline: deadline,\n            yesPool: 0,\n            noPool: 0,\n            status: MarketStatus.Active,\n            outcome: Outcome.Pending,\n            actualValue: 0,\n            dataSource: \"\"\n        });\n        \n        emit MarketCreated(marketId, question, targetValue, deadline);\n        return marketId;\n    }\n    \n    /**\n     * @dev Stake USDC on YES or NO\n     * @param marketId Market to stake on\n     * @param amount USDC amount (in smallest unit, e.g., 1000000 = 1 USDC)\n     * @param isYes true = YES, false = NO\n     */\n    function stake(uint256 marketId, uint256 amount, bool isYes) external {\n        Market storage market = markets[marketId];\n        require(market.status == MarketStatus.Active, \"Market not active\");\n        require(block.timestamp < market.deadline, \"Betting closed\");\n        require(amount > 0, \"Must stake > 0\");\n        \n        // Transfer USDC from staker to contract\n        require(usdc.transferFrom(msg.sender, address(this), amount), \"Transfer failed\");\n        \n        // Record stake\n        Stake storage userStake = stakes[marketId][msg.sender];\n        require(userStake.amount == 0, \"Already staked\"); // One stake per market per user\n        \n        userStake.amount = amount;\n        userStake.isYes = isYes;\n        \n        // Update pools\n        if (isYes) {\n            market.yesPool += amount;\n        } else {\n            market.noPool += amount;\n        }\n        \n        emit Staked(marketId, msg.sender, amount, isYes);\n    }\n    \n    /**\n     * @dev Resolve market with real data from Billy.dk\n     * @param marketId Market to resolve\n     * @param actualValue Actual value from Billy invoices\n     * @param dataSource Reference to source (e.g., \"Billy Invoice #1234\")\n     */\n    function resolve(\n        uint256 marketId,\n        uint256 actualValue,\n        string calldata dataSource\n    ) external onlyOwner {\n        Market storage market = markets[marketId];\n        require(market.status == MarketStatus.Active, \"Already resolved\");\n        require(block.timestamp >= market.deadline, \"Deadline not reached\");\n        \n        market.actualValue = actualValue;\n        market.dataSource = dataSource;\n        market.status = MarketStatus.Resolved;\n        \n        // Determine outcome\n        if (actualValue >= market.targetValue) {\n            market.outcome = Outcome.Yes;\n        } else {\n            market.outcome = Outcome.No;\n        }\n        \n        emit MarketResolved(marketId, market.outcome, actualValue, dataSource);\n    }\n    \n    /**\n     * @dev Claim winnings after market resolved\n     * @param marketId Market to claim from\n     */\n    function claim(uint256 marketId) external {\n        Market storage market = markets[marketId];\n        require(market.status == MarketStatus.Resolved, \"Not resolved\");\n        \n        Stake storage userStake = stakes[marketId][msg.sender];\n        require(userStake.amount > 0, \"No stake\");\n        require(!userStake.claimed, \"Already claimed\");\n        \n        uint256 payout = 0;\n        \n        // Calculate payout\n        if (market.outcome == Outcome.Yes && userStake.isYes) {\n            // Winner: staked on YES and outcome was YES\n            uint256 totalPool = market.yesPool + market.noPool;\n            payout = (userStake.amount * totalPool) / market.yesPool;\n        } else if (market.outcome == Outcome.No && !userStake.isYes) {\n            // Winner: staked on NO and outcome was NO\n            uint256 totalPool = market.yesPool + market.noPool;\n            payout = (userStake.amount * totalPool) / market.noPool;\n        }\n        // Losers get 0\n        \n        userStake.claimed = true;\n        \n        if (payout > 0) {\n            require(usdc.transfer(msg.sender, payout), \"Payout failed\");\n            emit Claimed(marketId, msg.sender, payout);\n        }\n    }\n    \n    /**\n     * @dev Get market details\n     */\n    function getMarket(uint256 marketId) external view returns (\n        string memory question,\n        uint256 targetValue,\n        uint256 deadline,\n        uint256 yesPool,\n        uint256 noPool,\n        MarketStatus status,\n        Outcome outcome,\n        uint256 actualValue\n    ) {\n        Market storage market = markets[marketId];\n        return (\n            market.question,\n            market.targetValue,\n            market.deadline,\n            market.yesPool,\n            market.noPool,\n            market.status,\n            market.outcome,\n            market.actualValue\n        );\n    }\n}\n"
      }
    }
  }
}